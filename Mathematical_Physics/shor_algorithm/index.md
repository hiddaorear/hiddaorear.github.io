# 深入浅出 Shor's Algorithm

## 起：Shor's Algorithm 和量子计算机简介

- 可逆
- 叠加
- 纠缠
- 计算加速

秀尔算法（Shor's Algorithm）是数学家彼得·秀尔（Peter Williston Shor）在1994年发现的算法，又称量子质因数分解算法。这个算法在量子计算机领域很重要。1982年，诺贝尔物理学奖得主费曼在演讲《用计算机模拟物理》（Simulating Physics with Computers）提出经典计算机无法高效模拟量子系统。12年后，秀尔提出能在多项式时间内分解大整数（RSA加密的基础），远超传统计算机的能力，引发量子计算研究的热潮。秀尔因此获得了理论计算机科学成就的最高奖——内万林纳奖（Nevanlinna Prize）。秀尔算法的影响深远，时至今日，说起量子计算机的进展，常见到秀尔算法的实现，支持能把 15 分解为 $5 \times 3$ 之类的叙述（2001 年IBM的量子计算机）。

量子力学是科幻作品中的常客，刘慈欣先生的《三体》中的球状闪电，在他的另一本书《球状闪电》中，很生动描述的量子力学的哥本哈根诠释。量子力学中还有薛定谔的猫，大名鼎鼎的物理学四大神兽之一，其他三只是拉普拉斯兽，麦克斯韦妖，芝诺的乌龟。薛定谔的猫让人疑惑的问题是量子力学的量子态的叠加。

设死猫的量子态: 
$$
|0\rangle
$$ 

活猫的量子态: 
$$
|1\rangle
$$

箱子中的猫就是这两个量子态的叠加：

$$
\alpha|0\rangle + \beta|1\rangle
$$

其中 $\alpha$ 和 $\beta$ 是概率幅，可以是正数、负数、复数。量子傅立叶变换就跟概率幅相关。去测量猫是死还是活的时候，结果是死猫 $\|0\rangle$ 概率是 $\alpha^2$，同理活猫的概率是 $\beta^2$。薛定谔的猫不生不死，就是叠加态。在传统计算机中，1 比特要么是高电平 1，要么是低电平 0，一个比特的值是确定的。量子计算机中比特既可以是 0，也可以 1，二者叠加在一起。考察这个存储上的特点，在 L 个比特上，量子计算机可以同时表达 $2^L$ 个数，而传统计算机只能表达 1 个数，量子计算机是传统计算机的  $2^L$ 倍。

除了存储，还有计算操作上的不同。传统计算机中通过门电路计算。量子计算机是幺正变换，实现量子门。例如 Hadamard 变换实现单比特的 H 门，是一个幺正矩阵：

$$
\frac{1}{\sqrt{2}} \begin{bmatrix}1&1\\1&-1\\ \end{bmatrix}
$$

H 门的作用，把一个量子比特转换为 $\|0\rangle$ 和 $\|1\rangle$ 的叠加态。

$$
|0\rangle \to \frac{1}{\sqrt{2}} \left( |0\rangle + |1\rangle \right) 
$$

$$
|1\rangle \to \frac{1}{\sqrt{2}} \left( |0\rangle - |1\rangle \right)
$$

H 变换的逆矩阵是他自身。即： $H*H = I$。那么在量子计算机里面，连续做两次变换，就相当于没有做变换，会把量子比特变会原来的样子，也就是量子计算是可逆的。这与传统计算机迥然不同。

当有 L个比特，表示的 $ 2^L $ 个数据，在 H 门中变换，H 门一次性就操作完成了。在传统计算机中需要  $ 2^L $ 次操作。忽略 H 门和传统电路计算的差异，量子计算机相对传统计算机，做了 $ 2^L $ 加速，效果很像传统计算机中的并行计算。

量子之间可以叠加，还可以纠缠。当2个电子纠缠在一起，一个电子自旋向上，另一个电子自旋向下。此时，测量一个电子自旋，若为向上，另一个电子必然会向下，反之亦然。即使两个电子之间隔着一个银河系也是如此。量子纠缠有大名鼎鼎的贝尔不等式实验证明。刘慈欣先生的《三体》中智子，与三体人的通信，设定上是通过量子纠缠实现。

综上所述，量子计算的计算是可逆的。量子态可以叠加，也可以纠缠在一起。利用量子的这些特性，可以实现相对于传统计算机的性能，有指数级的提升。

## 承：Shor's Algorithm 例子

使用 Shor's Algorithm 算法来分解 N：15。步骤如下：

- 先选一个小于 15 的整数，如 a：2；
- 计算  $2^r \mod 15$ ;

  | 指数 $r$    | $2^r$         | $2^r \mod 15$   |
  |------------|---------------|------------------|
  | *0*        | 1             | *1*              |
  | 1          | 2             | 2                |
  | 2          | 4             | 4                |
  | 3          | 8             | 8                |
  | *4*        | 16            | *1*              |
  | 5          | 32            | 2                |
  | 6          | 64            | 4                |
  | 7          | 128           | 8                |
  | *8*        | 256           | *1*              |
  | 9          | 512           | 2                |
  | 10         | 1024          | 4                |
  | 11         | 2048          | 8                |

- 考察一下  $2^r \mod 15$ 的结果，以 4 为周期循环出现：$1 \to 2 \to 4 \to 8$，以此重复，周期 r 等于 4;
- 通过周期 r 来分解 15:

$$
2^r \equiv 1 (\mod 15) \\
2^r - 1 \equiv 0 (\mod 15) \\ 
(2^{r/2} + 1)(2^{r/2} - 1) \equiv 0 (\mod 15)
$$

$(2^{r/2} + 1)(2^{r/2} - 1)$中，$2^{r/2} + 1 $ 或者 $2^{r/2} - 1$ 是 15 的质因数。这里得到了 15 的分解结果： $5 \times 3$。

在这个例子中，$2^r \mod 15$ 是否一定就是周期性呢？答案是肯定的。数论中的欧拉定理：

> 若 n，a 为正整数，且n和a互素（$gcd(a,n) = 1$），则 $a^{\phi(n)} \equiv 1 (\mod p) $。

即 $a^{\phi(n)} $ 与 1 在模 n 下同余。$\phi(n)$ 为欧拉函数，是小于 n 的正整数中，与 n 互质的数的数目。当 n 是质数的时候，$phi(n)$ 的值为 $p - 1$，欧拉定理就变为费马小定理：$a^{n - 1} \equiv 1 (\mod n)$

所举的例子是简单的情况。遇到 r 是奇数，则需要重新计算。遇到 $a^{p - 1} \equiv 1 (\mod k \times n) $，其中 k 为正整数，则需要 $gcd(a^{r/2} + 1,k \times n)$ 或 $gcd(a^{r/2} - 1,k \times n)$

## Shor's Algorithm 的实现

- [量子算法剖析: 零基础搞懂Shor量子算法推演](https://zhuanlan.zhihu.com/p/106923175)

##  转：Shor's Algorithm 背后的数学物理

### 量子纠缠

### 欧拉定理
- 求最后几位

### 傅立叶变换
- 评价
- 多项式乘法
- 逆变换


### 酉空间

- 傅立叶变换的广泛性（薛定谔方程、热传导）
- 为什么可逆

- [如果把傅里叶变换突然一键删除，世界上会发生什么变化？](https://www.zhihu.com/question/13671804165/answer/1888868718425134475)

## 合：学数学是学思想

### 数据类型背后的数学

### 同构的数学思想

重视语言特性，而不是重视语言

golang的error设计

- [Golang 有什么致命的问题吗？](https://www.zhihu.com/question/311207855)

