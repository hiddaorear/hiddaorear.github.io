# 深入浅出 Shor's Algorithm

## 起：Shor's Algorithm 和量子计算机简介

- 可逆
- 叠加
- 纠缠
- 计算加速

秀尔算法（Shor's Algorithm）是数学家彼得·秀尔（Peter Williston Shor）在1994年发现的算法，又称量子质因数分解算法。这个算法在量子计算机领域很重要。1982年，诺贝尔物理学奖得主费曼在演讲《用计算机模拟物理》（Simulating Physics with Computers）提出经典计算机无法高效模拟量子系统。12年后，秀尔提出能在多项式时间内分解大整数（RSA加密的基础），远超传统计算机的能力，引发量子计算研究的热潮。秀尔因此获得了理论计算机科学成就的最高奖——内万林纳奖（Nevanlinna Prize）。秀尔算法的影响深远，时至今日，说起量子计算机的进展，常见到秀尔算法的实现，支持能把 15 分解为 $5 \times 3$ 之类的叙述（2001 年IBM的量子计算机）。

量子力学是科幻作品中的常客，刘慈欣先生的《球状闪电》中，很生动描述的量子力学的哥本哈根诠释。量子力学中还有名鼎鼎的物理学四大神兽之一，薛定谔的猫。其他三只是拉普拉斯兽，麦克斯韦妖，芝诺的乌龟。薛定谔的猫让人疑惑的问题是量子力学的量子态的叠加。

设死猫的量子态: 
$$
|0\rangle
$$ 

活猫的量子态: 
$$
|1\rangle
$$

箱子中的猫就是这两个量子态的叠加：

$$
\alpha|0\rangle + \beta|1\rangle
$$

其中 $\alpha$ 和 $\beta$ 是概率幅，可以是正数、负数、复数。Shor 算法中量子傅立叶变换就跟概率幅可以为负数相关，可以放大我们想要的量子态的概率幅，从而测量的时候有更高的概率获取到我们想要的结果。去测量猫是死还是活的时候，结果是死猫 $\|0\rangle$ 概率是 $\alpha^2$，同理活猫的概率是 $\beta^2$。薛定谔的猫不生不死，就是叠加态。在传统计算机中，1 比特要么是高电平 1，要么是低电平 0，一个比特的值是确定的。量子计算机中比特既可以是 0，也可以 1，二者叠加在一起。考察这个存储上的特点，在 L 个比特上，量子计算机可以同时表达 $2^L$ 个数，而传统计算机只能表达 1 个数，量子计算机是传统计算机的  $2^L$ 倍。

除了存储，还有计算操作上的不同。传统计算机中通过门电路计算。量子计算机是幺正变换，实现量子门。例如 Hadamard 变换实现单比特的 H 门，是一个幺正矩阵：

$$
\frac{1}{\sqrt{2}} \begin{bmatrix}1&1\\1&-1\\ \end{bmatrix}
$$

H 门的作用，把一个量子比特转换为 $\|0\rangle$ 和 $\|1\rangle$ 的叠加态。

$$
|0\rangle \to \frac{1}{\sqrt{2}} \left( |0\rangle + |1\rangle \right) 
$$

$$
|1\rangle \to \frac{1}{\sqrt{2}} \left( |0\rangle - |1\rangle \right)
$$

H 变换的逆矩阵是他自身。即： $H*H = I$。那么在量子计算机里面，连续做两次变换，就相当于没有做变换，会把量子比特变会原来的样子，也就是量子计算是可逆的。这与传统计算机迥然不同。

当有 L个比特，表示的 $ 2^L $ 个数据，在量子门中一次就操作完成了。在传统计算机中分别对 $ 2^L $ 个数据处理，则需要  $ 2^L $ 次操作。忽略量子门和传统电路计算速度的差异，量子计算机相对传统计算机，相当于做了 $ 2^L $ 加速。效果很像传统计算机中的并行计算，并非严格意义上并行计算。

量子之间可以叠加，还可以纠缠。当2个电子纠缠在一起，一个电子自旋向上，另一个电子自旋向下。此时，测量一个电子自旋，若为向上，另一个电子必然会向下，反之亦然。即使两个电子之间隔着一个银河系也是如此。量子纠缠有大名鼎鼎的贝尔不等式实验证明。刘慈欣先生的《三体》中智子，与三体人的通信，设定上是通过量子纠缠实现。

综上所述，量子计算的计算是可逆的。量子态可以叠加，也可以纠缠在一起。利用量子的这些特性，可以实现相对于传统计算机的性能，有指数级的提升。

## 承：Shor's Algorithm 例子

使用 Shor's Algorithm 算法来分解 N：15。步骤如下：

- 先选一个小于 15 的整数，如 a：2；
- 计算  $2^r \mod 15$ ;

  | 指数 $r$    | $2^r$         | $2^r \mod 15$   |
  |------------|---------------|------------------|
  | *0*        | 1             | *1*              |
  | 1          | 2             | 2                |
  | 2          | 4             | 4                |
  | 3          | 8             | 8                |
  | *4*        | 16            | *1*              |
  | 5          | 32            | 2                |
  | 6          | 64            | 4                |
  | 7          | 128           | 8                |
  | *8*        | 256           | *1*              |
  | 9          | 512           | 2                |
  | 10         | 1024          | 4                |
  | 11         | 2048          | 8                |

- 考察一下  $2^r \mod 15$ 的结果，以 4 为周期循环出现：$1 \to 2 \to 4 \to 8$，以此重复，周期 r 等于 4;
- 通过周期 r 来分解 15:

$$
2^r \equiv 1 (\mod 15) \\
2^r - 1 \equiv 0 (\mod 15) \\ 
(2^{r/2} + 1)(2^{r/2} - 1) \equiv 0 (\mod 15)
$$

$(2^{r/2} + 1)(2^{r/2} - 1)$中，$2^{r/2} + 1 $ 或者 $2^{r/2} - 1$ 是 15 的质因数。这里得到了 15 的分解结果： $5 \times 3$。

在这个例子中，$2^r \mod 15$ 是否一定就是周期性呢？答案是肯定的。数论中的欧拉定理：

> 若 n，a 为正整数，且n和a互素（$gcd(a,n) = 1$），则 $a^{\phi(n)} \equiv 1 (\mod p) $。

即 $a^{\phi(n)} $ 与 1 在模 n 下同余。$\phi(n)$ 为欧拉函数，是小于 n 的正整数中，与 n 互质的数的数目。当 n 是质数的时候，$phi(n)$ 的值为 $p - 1$，欧拉定理就变为费马小定理：$a^{n - 1} \equiv 1 (\mod n)$

所举的例子是简单的情况。遇到 r 是奇数，则需要重新计算。遇到 $a^{p - 1} \equiv 1 (\mod k \times n) $，其中 k 为正整数，则需要 $gcd(a^{r/2} + 1,k \times n)$ 或 $gcd(a^{r/2} - 1,k \times n)$

## Shor's Algorithm 的实现

1. 用 H 门制作正整数 N 的长度为 L 的处于叠加态的量子比特，存入寄存器 register1 中；
2. 用 register1 中的值计算 $a^x \mod N$ ，并使二者纠缠，存入寄存器 register2 中；
  以 $2^r \mod 15$ 为例子，经过1和2，此时得到如下结果：

    | 指数 $r$   |register1：$2^r$|register2：$2^r \mod 15$|
    |------------|---------------|------------------|
    | *0*        | 1             | *1*              |
    | 1          | 2             | 2                |
    | 2          | 4             | 4                |
    | 3          | 8             | 8                |
    | *4*        | 16            | *1*              |
    | 5          | 32            | 2                |
    | 6          | 64            | 4                |
    | 7          | 128           | 8                |
    | *8*        | 256           | *1*              |
    | 9          | 512           | 2                |
    | 10         | 1024          | 4                |
    | 11         | 2048          | 8                |

3. 由数论中的欧拉定理，寄存器 register2 中的值，会以 r 为周期重复出现；为了简化问题的论述，假设 $r \mod L = 0$;
4. 若 r 不为偶数，则重新选择 a 计算；
5. 周期 r 在 register2 中，我们需要设法获取周期 r 的值，利用 $(a^{r/2} + 1)(a^{r/2} - 1) \equiv 0 (\mod N)$，求得 N 的因数。我们的重心是周期 r， $a^x \mod N$ 的具体值并不重要，由于每次测量只能获取一个值，我们也无法通过直接测量值来计算周期。
    为了获取周期，考虑使用量子傅立叶变换，获取频率ν，从而取得周期 $r = 1 / ν$。为了使量子傅立叶变换更好处理，我们可以只用保留周期 r 中的某一个值，把其他值变为0，这一操作不影响最终结果，却使得计算和测量更好处理。对 register2 进行一次测量以后，得到一个值 γ。因为 register1 与 register2 纠缠，register1 中的量子也塌缩，剩下与 γ 相关的量子态；
    假设 register2 测量的所得值为 1，此时两个寄存器量子态如下：

    | 指数 $r$   |register1：$2^r$|register2：$2^r \mod 15$|
    |------------|---------------|------------------|
    | *0*        | 1             | *1*              |
    | 1          | 0             | 0                |
    | 2          | 0             | 0                |
    | 3          | 0             | 0                |
    | *4*        | 16            | *1*              |
    | 5          | 0             | 0                |
    | 6          | 0             | 0                |
    | 7          | 0             | 0                |
    | *8*        | 256           | *1*              |
    | 9          | 0             | 0                |
    | 10         | 0             | 0                |
    | 11         | 0             | 0                |
6. 周期 r 依然隐含在量子态中。此时进行量子傅立叶变换，与周期不相关的量子态的概率幅会相消，与周期相关的量子态概率幅会增加（概率幅的平方即概率），再进行一次测量，就有很大的概率获得一个与周期 r 相关的一个数，进一步处理即可求得周期。这里也有小概率会失败，就需要重新计算一遍；下文会给出成功的概率，是与 L 相关的数，L 越大，概率越高；

- [量子算法剖析: 零基础搞懂Shor量子算法推演](https://zhuanlan.zhihu.com/p/106923175)

##  转：Shor's Algorithm 背后的数学物理

### 量子纠缠

### 欧拉定理
- 求最后几位

### 傅立叶变换
- 评价
- 多项式乘法
- 逆变换


### 酉空间

- 傅立叶变换的广泛性（薛定谔方程、热传导）
- 为什么可逆

- [如果把傅里叶变换突然一键删除，世界上会发生什么变化？](https://www.zhihu.com/question/13671804165/answer/1888868718425134475)

## 合：学数学是学思想

### 数据类型背后的数学

### 同构的数学思想

重视语言特性，而不是重视语言

golang的error设计

- [Golang 有什么致命的问题吗？](https://www.zhihu.com/question/311207855)

