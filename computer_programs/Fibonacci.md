# 群与编程

## 计算 Fibonacci numbers

### 定义

F_0 = 0
F_1 = 1
F_n = F_n-1 + F_n-2

### 依据定义实现

``` C++

int fib0(int n) {
	if (n == 0) return 0;
	if (n == 1) return 1;
	return fib0(n - 1) + fib0(n - 2);
}

```

这个实现做了很多重复运算。例如fib0(5):

```

F5 = F4 + F3
   = (F3 + F3) + (F2 + F1)
   = ((F2 + F1) + (F2 + F1)) + ((F1 + F0) + F1)
   = (((F1 + F0) + F1) + ((F1 + F0) + F1)) + ((F1 + F0) + F1)

```

我们看到`(F1 + F0)`被重复计算了3次。用T(n)标识fib0所需要的基本操作次数。如果`n < 2`，程序很快结束，仅仅执行很少的操作，从而有：

` 当n <= 1 时，T(n) <= 2`

当n增大，fib0被递归调用2次，还有3次基本操作，故：

`等 n >= 1 时，T(n) = T(n-1) + T(n-2) + 3`

我们将此与Fn的递推关系比较，可知`T(n) >= Fn`。即算法的复杂度和Fibonacci数的增长速度一样。而Fibonacci数的与2的幂增长速度相当，大概是`Fn = 2 ^ (0.694n)`


### 求Fibonacci数通项

线性代数办法。


注：生成函数求Fibonacci数通项见《具体数学》。

### 带缓存的实现

``` C++
#include <utility>

int fib1(int n) {
	if (n == 0) return 0;
	std::pair<int, int> v = {0, 1};
	for (int i = 1; i < n; ++i) {
		v = {v.second, v.firt + v.second};
	}
	return v.second;
}

```

这个算法的复杂度是O(n)。fib1的复杂度是关于n的线性的，从指数降至多项式n。


### 大数的情况

在fib0和fib1中，我们都将`+`操作视为基本操作，认为消耗的时间是常量。而实际上大数的算术操作不能在常量的时间内完成。在大数的情况，我们需要对算法的复杂度重新计算。两个n为的二进制数的加法复杂度正比于n。

那么在fib1算法中，大概进行了Fn次加法操作，即fib2的在大数情况下的复杂度为`n^2`。仍然是n的多项式，依然比fib0的指数级算法优越。

### 用矩阵来求Fibonacci数

我们用矩阵来表示求Fibonacci数的操作：

```
 F_n+1  = 0 1 * F_n
 F_n+2    1 1   F_n+1

```

第n个Fibonacci数的计算：

令:

```
A = 0 1
    1 1
```

```
 F_n+1  = A^n * F_n
 F_n+2          F_n+1

```

记此算法为fib2。

即计算Fn只需要计算矩阵A的自乘。计算`A^n`需要多少次矩阵乘法呢？考虑n为偶数，`n = 2^k`，实际k次即可计算出结果，即O(logn)次乘法。

用矩阵的算法只需O(logn)次，而fib1需要O(n)次，我们的算法又得到新的提示。

我们分析一下，矩阵的算法性能提升的原因在于，算法中不只有加法，还有乘法。大数的乘法要慢于加法。考虑大数操作，fib1的复杂度变为`O(n^2)`。

假设两个n二进制数相乘的运行时间是M(n)，在没有优化的情况下，`M(n)=O(n^2)`。那么fib2的复杂度为`O(M(n)logn)`，M(n)的增长大于logn，故fib2的复杂度为O(M(n))。即fib2的算法能否比fib1快，取决于我们能否以少于O(n^2)的次数来完成两个n位数相乘。


## FFT

### 傅里叶变换

#### 多项式的两种表示

#### 以线性代数角度看傅里叶变换

### FFT算法

### FFT与大数相乘算法关系

## 求余运算与群

## Fibonacci heap

## 反思

### 大数相乘面试题

### 简单实现的缺点

### 数学的重要性

## change log

- 2020/7/19 下午 created doc
- 2020/8/9 下午
