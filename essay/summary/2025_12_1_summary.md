# lumina项目中胶水层的胶水层

## 自底向上和自顶向下

项目的层次结构设计，通常有两个方向。一个是自底向上，从具体到抽象，从业务的具体操作开始，向上进行。一个自顶向下，从抽象到具体，从高层对项目的应用逻辑开始，向下进行。

项目完全自顶向下，则存在应用逻辑所需的领域原语和真实的领域原语，无法匹配的风险。

项目完全自底向上，则存在做了许多与应用逻辑无法的工作的问题。

因此，工程中，二者兼备。用自顶向下的应用逻辑表达抽象，用自底向上思路来收集底层的领域原语。代码是自顶向下和自底向上综合的产物。项目中同时有自顶向下的自底向上的代码，这样就有连接二者的“胶水层”。 胶水层去匹配顶层的应用逻辑和底层的领域原语。

## 胶水层的胶水层

Unix中的经验教训：胶水层必须尽可能薄。

项目中的代码，如果既不属于应用逻辑，又不属于领域原语，那么代码除了会增加项目的复杂度，无其他用处。应用逻辑和领域原语，应当清晰分离。

现实项目往往没有做到清晰分离，就会导致胶水层设计的较糟糕的情况，在胶水层上加胶水层。

项目中开发觉察到胶水层的存在以后，很容易围绕胶水层自身设计，叠床架屋，把胶水层组织为一个中间层，这样就有了两个胶水层。胶水层越来越厚，项目陷入的焦油坑。

## 发布平台的胶水层

前端和终端的连接越来越紧密，终端的UI渲染使用了前端相近的设计。使用终端原生代码或JavaScript代码处理渲染逻辑，使用模版描述UI。前者相当于综合了前端的JavaScript和CSS，后者相当于HTML。

终端项目的通过CI的包，通常会拆分2个，一个用于处理业务逻辑，一个用于支持底层的架构依赖。前者称之为业务代码包，后者称之为vendor包。业务代码包更新频繁，不同的业务迭代所构建的业务代码包不同。而vendor包通常更新少，多一个业务代码包可以共用一个vendor包。

因此，终端需要同时获取业务代码包，以及所依赖的vendor包。而后台考虑到终端复用vendor包，业务代码包所依赖的vendor包如果有重复，则去重。

为了发布的安全，正式发布需要按版本灰度。业务代码包1和依赖的vendor包a，需要同时下发，已全量。随着迭代的进行，新业务代码包2和依赖的vendor包a，开始灰度10%。两次发布都共用了同一个vendor包a，一个全量100%，一个灰度了10%。

同一个vendor包a，有2个灰度的值。后台vendor包去重逻辑遇到问题，10%的会覆盖已全量的。

vendor的去重逻辑，既不是底层所需，同时也不是顶层的发布业务所需，属于胶水层。

为了修复问题，直接的思路是针对胶水层升级，去掉去重逻辑，或者vendor的灰度值统一为100%。后续项目迭代，终端依赖越来越复杂，这个胶水层就会越来越厚。

这违背了“胶水层必须尽可能薄”。考虑自底向上，梳理终端的领域原语。发布灰度的是业务代码包，而不是vendor包。vendor包是业务代码包的依赖，没有独立的灰度。

考虑自底向上的底层原语，后台控制业务代码包的灰度，再处理业务代码包依赖vendor即可，就无需考虑vendor包的去重逻辑。在“胶水层必须尽可能薄”的原则下，后续支持更复杂包依赖关系，后台也能胜任。

考虑自顶向下的应用逻辑，后台的关键是保障发布的新增的代码的安全，旧的代码包的安全性已然验证了。在此思路上，还可以演进出差量包，精准更新终端所需的代码。



