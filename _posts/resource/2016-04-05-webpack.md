---
layout: post
title:  Webpack
category: 资源
tags: [Webpack]
keywords: Webpack
description:
---

###  Webpack

#### Webpack

#### Tuesday, 05 April 2016

![landscape](/../../assets/img/resource/2016/ChenBi_3.jpg)

## 模块化系统方案

1. `<script>`标签（原始方案，不具备模块化系统）；
2. CommonJS，与nodejs类似的同步方案；
3. AMD，与浏览器加载类似的异步方案；
4. ES6
5. 其他

各自优缺点：

### `<script>`

缺点：
1. 在全局对象中，易冲突；
2. 顺序与依赖不易处理；
3. 后续管理维护不方便。

### CommonJS同步`require`

特点载入模块的方式是同步。

优点：
npm风格

缺点：
同步的方式，堵塞式的调用不适合浏览器环境；
不支持多模块同步加载。

用例：

````javascript

/**car.js**/
functin Car() {
  this.run = function() {
    console.log('Car run...')
  }
}

var car = new Car();
module.exports = car;

/**main.js**/
var Car = require('./car')
Car.run();

````

### AMD异步加载

优点：
符合浏览器加载需求；
可多个模块平行加载。

缺点：
不易维护；

````javascript

require(['module', './file'], function(module, file) {/*code here*/});

define('mymodule', ['dep1', 'dep2'], function(d1, d2) {
  return someExportedValue;
})

````

### ES6方案

优点：
静态分析容易(运行前得出模块的依赖关系)；
更好的支持循环依赖；
未来标准；

例子：

````javascript
// export
export let _ = functin() {};
export function lodash() {};
export default function(x) {return x;}; // 导出默认对象
export {_, lodash as default};

// import
import * as _ from 'src/lodash';
import {each, map} from 'src/lodash';
import _ from 'src/lodash'; // 导入默认对象
import _, {each, map} from 'src/lodash';
import 'src/lodash'; // 加载文件，但啥也不引入



````

### 传输方案

极端例子：
每一个模块一个请求；
所有模块合并成一个请求。
优化方案，按需加载。


## Webpack是什么

webpack将web开发中常用到的静态资源（JavaScript, CSS, img, Jade等文件）称之为模块，webpack是一个模块打包工具，兼容多种JavaScript书写规范，处理模块间打包关系。

前端开发常遇到的问题：

1. 项目在那个资源多样性和依赖性，我们需要借助gulp或者grunt来编译压缩JavaScript, CSS, png, LESS, Jade文件；
2. JavaScript模块复杂化，有AMD,CommonJS,UMD,ES6等规范文件；
3. 开发与线上文件不一致，打包压缩造成的影响。

Webpack特点：

1. 增量编译快，具有异步IO且有多级缓存；
2. 可以将代码切割成不同的chunk，按需加载，降低初始化时间；
3. 串联模块加载器以及插件机制，灵活易于扩展。

webpack相对于传统的gulp与grunt等工具，他能过非常精确的处理打包需求。webpack的本质只能处理JavaScript，但其他资源能被转换位JavaScript，因此任何模块都是JavaScript模块。

## Webpack里面的概念

### Loader

职责单一，输入字符串，输出字符串，与shell中管道一样支持组合串行。入参：sting, sourcemap，出参：string, sourcemap

举例：`style-loader!css-loader!less-loader!./foo.less`
foo.less通过less-loader编译成css，css-loader将css中的`url(xxx.png)`类图片提取出来，转化为`url(require(./xxx.png))`的形式（图片也是模块），而style-loader把此css插入到文档。

当我们require css或者scss，less等等的时候，webpack会把css转换为一行字符串并封装在JavaScript中，然后当我们执行require()会帮我们插入`<style>`标签到该页面，当我们require图片的时候，Webpack则会把图片转换为dataURI或带入链接。

### Plugin

Plugin能捕捉到整个编译阶段的更多的事件点，对编译过程由更全面的控制，相对于只能处理单一文件loader更加灵活。

举例：`ExtractTextPlugin`可以将所有文件中的css剥离到一个独立的文件中。

### Entry

即入口。每个入口都需要Webpack的runtime代码，其实主要就是AMD模块加载器，以及模块管理器。

## 关于模块化

模块化是前端工程中最为核心的部分。但以纯前端方式不能同时满足：按需加载，请求合并和依赖管理三个需求。而导致这个问题的根本原因是：纯前端方式只能在运行时分析依赖关系。

而新思路的策略很简单：不在运行时分析依赖。借助构建工具做线下分析：利用构建工具在线下进行模块依赖分析，然后把依赖关系数据写入到构建结果中，并调用模块化框架的依赖关系声明接口，实现模块管理，请求合并以及按需加载等功能。

## Gulp and Webpack

Gulp是一个优化前端工作流程的工具，Webpack是模块化的方案。

## Requirejs and Webpack

Requirejs是在线编译模块的方案，相当于在页面上加载一个CMD,AMD解释器。这样浏览器就认识了define,exports,module这些，实现模块化。

Webpack是一个预编译模块的方案，不需要在浏览器中加载解释器，不管是AMD,CMD,ES6风格的模块化，都能认识。

## 初级问题

#### 1. There is another module with an equal name when case is ignored.
This can lead to unexpected behavior when compiling on a filesystem with other case-semantic.
Rename module if multiple modules are expected or use equal casing if one module is expected.

此种警告，表示improt后面的字符串的名字大小写不对。如下：
`import ReactDOM from 'react-doM';`

#### 2. 把全局变量插入到所有代码中`webpack.ProvidePlugin`：

webpack提供一个插件 把一个全局变量插入到所有的代码中

```javascript
plugins: [
  new HtmlwebpackPlugin({
    title: 'Hello World app'
  }),
    
	//provide $, jQuery and window.jQuery to every script
  new webpack.ProvidePlugin({
    $: "jquery",
    jQuery: "jquery",
    "window.jQuery": "jquery"
  })
]
```

## 参考资料：

[Webpack——令人困惑的地方](https://github.com/chemdemo/chemdemo.github.io/issues/13)

[玩转webpack 深入理解原理](http://www.thkdog.com/html5/2015/05/08/webpack.html)

[前端工程与模块化框架](https://github.com/fouber/blog/issues/4)

[gulp + webpack 构建多页面前端项目](https://github.com/fwon/blog/issues/17)

[webpack 入门及实践](http://www.w3ctech.com/topic/1557)

[What、Why、How？解读Webpack官方文档](https://segmentfault.com/a/1190000003506497)

[Webpack傻瓜式指南（一）](http://zhuanlan.zhihu.com/p/20367175)

[Webpack傻瓜指南（二）开发和部署技巧](http://zhuanlan.zhihu.com/p/20397902?refer=FrontendMagazine)

[Webpack傻瓜指南（三）和React配合开发](http://zhuanlan.zhihu.com/p/20522487?refer=FrontendMagazine)

[Webpack 入门指迷](https://segmentfault.com/a/1190000003969465)

[gulp + webpack 构建多页面前端项目](https://segmentfault.com/a/1190000003969465)

[Creating a workflow with WebPack](http://christianalfoni.github.io/javascript/2014/12/13/did-you-know-webpack-and-react-is-awesome.html)

[webpack-howto](https://github.com/petehunt/webpack-howto/blob/master/README-zh.md)

[Vue + webpack 项目实践](http://jiongks.name/blog/just-vue/)

[基于webpack搭建前端工程解决方案探索](https://segmentfault.com/a/1190000003499526)

[webpack-best-practice-最佳实践-部署生产](http://qiutc.me/post/webpack-best-practice-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E9%83%A8%E7%BD%B2%E7%94%9F%E4%BA%A7.html)




hid say：凡是需要配置的东西，多少有些不耐烦。所以配置，一定要务求精简。
