---
layout: post
title:  Mastering Regular Expression(1)
category: 技术
tags: [Regular Expression]
keywords: Regulaer expression 
description: 
---

##### Tuesday, 07 April 2015

### 读《精通正则表达式》(一)

#### ----正则表达式初步

![龙猫](/../../assets/img/tech/2015/longmao.jpg)

> 所谓幸福,就是尽情地施展我们掌握的技能,等待期望的结果
---亚里士多德


### 所谓正则表达式,就是一种描述字符串结构模式的形式化表达方法.

再读正则表达式经典名著《精通正则表达式》第一章,与2013年我读本书的时候,感觉绝然不同,时移物换,快两年了.

正则表达式基本元素:
1.普通字符,匹配普通的字符串;
2.字符组以及字符组简记法,匹配一组字符串;
3.元字符,描述位置(^$),常用字符组集合(*.),量词(+?*),表示范围(-);
4.量词,*+?等;
5,分组,();
6.多选结构,|;

以上为正则表达式简单元素.正则表达式根植于数学理论,但不懂这背后的数学理论.读本书的第一章的时候,隐约感觉这一套符号,有专门处理字符串编程语言的影子.

编程语言的流程结构,顺序结构,选择结构,循环结构.普通字符有自己排列顺序,可以对应顺序结构.多选结构`|`对应选择结构,字符组"[string]"相当于"switch...case"结构.量词相当于for循环.分组"()"的子表达式相当于程序块,括号有三个功能:限制多选结构,分组和捕获文本,类似于编程语言中的函数.这样一套正则表达式的符号,就相当于一门字符串结构描述语言的简写.正则表达式有领域专用语言的味道.

> 所谓领域专用语言（Domain Specific Language/DSL），其基本思想是“求专不求全”，不像通用目的语言那样目标范围涵盖一切软件问题，而是专门针对某一特定问题的计算机语言。

> 正则表达式(Regular Expression)是很强大,便捷,高效的文本处理工具.正则表达式本身,加上如同一门袖珍语言的通用模式表示法(general pattern notaion),赋予使用者描述和分析文本的能力.

在分析和描述文本的时候,我们需要养成不管文本语义,而要分析文本本身具有的结构的习惯,分析文本本身时,应该按照单个字符来理解正则表达式,而不是有语义的单词.在分析字符串时,面对复杂的结构的时候,我们可以用表格来辅助分析,这样,很容易得出字符串里面的结果要素.

补充前些天读《正则指引》所画的思维导图,有很多技术细节,值得细读,是《精通正则表达式》目前没有提到的,估计后面会提到,作者可能为了初学者不至于掉入细节的泥潭,暂且略去.《正则指引》这本书的作者即是《精通正则表达式》译者.译者自身著作章节的结构更整饬,内容很破碎,因为作者不顾结构,发挥了作者实践遇到技术细节问题.可以看出作者技术功力深厚,钦佩之.文学欠佳,国人技术书籍的通病.

### NFA Non-deteminisic finite automaton 要义

### 1. 占有字符与零宽度
占有字符：如果子表达式匹配的是字符串，而非位置，并被保存在匹配结果中，则子表达式是占有字符的；
零宽度：如果子表达式匹配的仅仅是位置，或者匹配的内容并不保存到最终的匹配结果中，则子表达式是零宽度的。

占有字符互斥，零宽度非互斥。同一个字符，同一时间只能由一个表达式匹配，而同一个位置，却可以同时由多个零宽度的子表示匹配。

正则中匹配包含两个匹配因素，字符串与位置。字符串的匹配是某个位置的字符串的匹配，所以字符串匹配隐含位置信息，位置与字符串唯一确定了匹配，故占有字符匹配唯一；位置是相对，故位置表达可以多样，且位置只是辅助字符串的匹配，故不唯一。

### 控制权和传动
对于整个表达式来说，通常有字符串位置0开始尝试匹配。如果在位置0开始尝试，匹配到某一位置时整个表达式失败，那么引擎会使正则向前传动，整个表达式从位置1开始重新尝试匹配，依此类推，直到报告匹配成功或尝试到最后一个位置报告失败。

NAF的匹配过程的要义在于回溯，特别是在有匹配量词的情况下，匹配过程中匹配不成功，会回溯以前的备用状态。想起了BackTrack Linux，“The quieter you become, the more you are able to hear...”

### 匹配的方向

贪婪匹配：
表示方法： 简单量词都是贪婪匹配。(`?, *, +`)
描述：贪婪模式是先匹配整个字符串，相当于从右到左的匹配。匹配原则类似在正则表达式末尾加上`$`，如果匹配失败，则去掉末尾，回溯，直到匹配成功。如果是全局匹配，匹配成功之后可以在此基础上继续进行匹配操作。

`/.*reg/`会匹配aa之前的所有字符，而不仅仅是reg之前第一个，`/.*?reg/`则只匹配reg之前第一个。
贪婪模式开启全局与不开启全局，结果以i杨，以为非贪婪模式就是贪婪到底，与全局匹配要匹配多次一样。
而惰性模式则不一样。

`'abcdefg'.replace(/[a-z]+?/g, '0')` => '0000000'
`'abcdefg'.replace(/[a-z]+?/, '0')` => '0bcdefg'

惰性匹配：
表示方法： 在量词后面添加`?`, `??, *?, +?`
描述：惰性匹配与贪婪匹配相反，是从左到右的匹配。先匹配第一字符，如果匹配失败，则增加一个字符，直到匹配成功。


![正则指引](/../../assets/img/tech/2015/RegularExpression_0.png)

### 细节补充

1.字符组

2.普通字符组

> 正则表达式处理的都是字符串(String)而不是字符

> 字符组就是一组字符,正则表达式表示"同一位置可能出现的各种字符"

3.元字符与转义

> "-",若紧邻"[",则是普通字符,其他情况下是元字符,表示范围

> "["与"]"转义时,只有开括号需要转义,闭括号"]"不需要转义

4.排除性字符组

> 若需要表示"-"(不是用于表示范围),则需紧跟在"^"之后

> 字符组简记法
> \d(digit),数字,排除型字符组为\D
> \w(word),[_0-9a-zA-Z],单字字符,排除型字符组为\W,注意包括了下划线"_",如果匹配"数字和字母",不能用"\w",[0-9a-zA-Z]才是正确的选择
> \s(space),[\t\r\n\v\f],空白字符,排除型字符组为\S

> 技巧:利用字符组简记法的互补特性,可以得到任意字符,[\s\S]等.许多语言的正则表达式并没有直接提供"任意字符"的表示法.注意"."能匹配"任意字符",但默认的情况下其实不能匹配换行符

### 正则实战(1)

参考：[将一般的数值转换为金额格式（分隔千分位和自动增加小数点）](http://www.cnblogs.com/mofish/p/3188203.html)
有改动，简化程序。

````javascript

// '123456789'  => '123,456,789.00'
//逗号分隔整数位，小数不够两位的自动补齐。

//不考虑小数点
'12345678'.replace(/(\d{1})(?=(\d{3})+(\.|$))/, function(s) {
  return s + ','
})

// => 12,345,678
````

考虑小数情况，使用正则实现：

````javascript

var FormatNum = function(num) {
  var _reg = /(\d)(?=(\d{3}+(\.|$)))/g
  if ((num typeof num) && (num.indexOf('.') === -1)) {
    num = num.replace(_reg, ',') + '.00'
  } else {
     var _num_array = num.split('.')
     var _num_int = _num_array[0].repalce(_reg, ',')
     
     if (_num_array[1].length === 1) {
      return _num_int + '.' + _num_array[1] + '0'
     } else if (_num_array[1].length > 1) {
      var _decimals = _num_array[1].substr(0, 2)
      return  _num_int + '.' + _decimals
     }
  }
}

````

循环实现：

````javascript

var FormatNum = function(num) {
  var _num = ''
      ,i = 0
      ,l = 0
      ;
  
  if (num.indexOf('.') === -1) {
    l = num.length
    i = l
    for (; i > 0; i--) {
      if (i !== 0 && i % 3 === 0) {
        _num = num[i] + ',' + _num
      } else {
        _num = num[i] + _num
      }
    }
    return _num + '.00'
  } else {
    l = num.indexOf('.') -1
    i = l
    for (; i > 0; i--) {
      if (i !== 0 && i % 3 === 0) {
        _num = num[i] + ',' + _num
      } else {
        _num = num[i] + _num
      }
    }
    return _num + (num + '00').substr(num.indexOf('.'), 2)
  }
} 

````


### 参考资料

[JS正则](https://www.gitbook.com/book/longze/javascript-regexp/details)
[js中贪婪和惰性匹配](http://www.cnblogs.com/zera/archive/2013/01/14/2860121.html)
[正则基础之——环视](http://blog.csdn.net/lxcnn/article/details/4304754)
[正则表达式 - 维基百科，自由的百科全书](http://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F)
[领域专用语言(DSL)迷思](http://www.infoq.com/cn/articles/dsl-discussion)
[正则基础之——NFA引擎匹配原理](http://blog.csdn.net/lxcnn/article/details/4304651)

hid say:使用技术的时间不一样,对技术的领悟也不不一样,不独技术会随时间发展,人的感悟也随流年而异.很多年以后,人和技术会是怎样的呢?人们身边的人呢?


