---
layout: post
title:  文本之正则表达式
category: 技术
tags: [text]
keywords:  text regular expression
description:
---

###  文本之正则表达式

#### Saturday, 16  2017 September

![ChengBi](/../../assets/img/tech/2017/ChengBi_3.jpg)

## 本质

### DFA与NFA

正则表达式有两种引擎，DFA和NFA。两者区别是DFA不支持捕获型括号(capturing parentheses)，不支持回溯(backreferences)。两者的具有相同的本质，他们都是自动状态机，都会从一个匹配的状态转移至下一个或几个状态。

DFA从一个状态转移至下一个确定的状态，而NFA则从一个状态转移至下一个不确定的状态。或者既然状态不确定，那么在程序中如何执行呢？NFA猜出所有的状态，并执行。如何猜呢？暴力遍历所有的可能的状态。从这个角度看，NFA是多个DFA的组合，故两者等价。但匹配的过程的差异，导致部分情况下NFA性能不如DFA，这个是显然的，NFA遍历的状态多于DFA。还有不显然的差异，由于NFA会记录遍历匹配的过程，故可以在匹配的历史中回溯，以及捕获其匹配的字符串。而在生产环境中，两者都是很有用的功能，故多数编程语言使用NFA。也有结合两者使用的情况，DFA可以获得好的性能，NFA可以有更多的功能。

### NFA的匹配本质有2种：

1. 匹配字符导致状态转移，如普通的字符；
2. 不用匹配字符就可以导致状态转移，即ε匹配，如括号；

### 匹配字符有4种情况：

1. 单个字符c的匹配；
2. 连接：(PQ)，如果字符串s1满足P，字符串s2满足Q，则s1s2满足(PQ)；
3. 或：`(P|Q)`，如果字符串s满足P或者Q，则s满足`(P|Q)`；
4. Kleene closure，`(P*)`。如果字符串s可以写成0个或多个字符串c的连接c1c2c3···，且每一个串都满足`(P*)`，则s满足`(P*)`。注意空字符串也满足。

其中克莱因闭包的优先级最高，连接次之，或最低。







## 第一原则

从实践的角度，写正则表达式，应该文本优先。即根据文本来构造正则表达式。我们知道匹配过程中有类似结构化编程中的三种结构，顺序(字符串)、选择(`| []`等结构)与循环(`+ *`等量词)。但如此会陷入细节中，导致考虑不全面，构造起来也不便捷。由于NFA是匹配优先，我们可以将字符串分组，用括号括起来即可。马上可以知道字符串的结构，然后分析三种情况，必须匹配，必须不匹配，可能匹配。用括号分割字符串，即可知道那些是必须匹配的，多数情况到这一步即可。

而正则表达式一般用4种情况：

1. 校验；（表单校验`/RegExp/.test(str)`,`str.indexOf(searchString)`）
2. 捕获；（url解析并获取参数`str.match(/RegExp/)`）
3. 替换；（模版引擎`str.replace(/RegExp/, (c) => { return c })`）
4. 切分；（以分隔符切分字符串`str.split(/RegExp/)`）

例子：匹配URL。`http://www.ora.com:80/goodparts?q#fragment`

1. `(http:)(//)(www.ora.com)(:80)(/goodparts)?(q)(#fragment)`

2. `/([A-Za-z]+)?(\/{0, 3})([0-9.\-A-Za-z]+)(\d+)?(\/\w+)?(\?\w+)?(#\w*)?/`

3. `/([A-Za-z]+)?(\/{0, 3})([0-9.\-A-Za-z]+)(\d+)?(\/\w+)?(\?[^?#]+)?(#(.*))?/`

4. `/^(?:([A-Za-z]+):)?(\/{0,3})([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$`

以上为构造URL的正则过程，分组时要留意匹配前后的关联性。尽量不使用`.*`，优先使用排他性字符组，使得匹配的结果更加精确，减少回溯，性能更好。过多的回溯，可能导致正则表达式的效率与最初级的字符串处理算法一样。


## 知识结构

### 缩写法

正则表达式是处理字符串的匕首，小而锋利。但也有正则表达式不能处理的情况，正则表达式的局限。比如，不存在能够描述所有合法正则表达式字符串的集合的正则表达式，其简化版：无法使用正则表达式检查括号是否匹配，检查字符串中A和B是否一样多。也就是正则表达式无法用自身描述自身。这其中困难之处在于，正则表达式用来处理字符串，而正则表达式本身也是用字符串描述的。字符串的组合千变万化，但总是在一个字符串集合中，正则表达式就是从这些集合中抽象处理来的模式，即某些字符串集合的缩写。

我们知道匹配到字符串导致状态转移有4中情况，其中连接和或是一种，而克莱因闭包是另一种。前者我们可以使用一个字符集来描述，如通配符`.`，字符组`[A-Z]`，补集`[^aeiou]`，以及简写`\w \d \s`。后者克莱因闭包则是各种量词，如`+ {1, } ? {0, 1} * {0, }`。

既然前面我们使用缩写来表示字符集，那么我们需要匹配这些表示缩写的字符时怎么办呢？在正则表达式中，处理这种情况的办法是使用转义，在字符之前加上斜杠即可。

### ε匹配

1. 括号：分组，非捕获分组

2. 断言：单个位置，环视

### 匹配模式

i
g
m


## 技巧


## 易忽略的点

非捕获型匹配

断言`(?!string)`



# 参考资料：

正则指引 by 余晟

Algorithms by Robert Sedgewick and kevin Wayne

Mastering Regular Expressions Undrstand Your Data and Be More Productive by Jeffrey E.F. Friedl

JavaScript: The Good Parts by Douglas Crockford

Yvan say：很多时候，我们没有意识到正则表达式，其实对我们自身很有用处。正则的用处，不仅仅是用于面试，或者开发中做校验功能。正则对我们开发本身，就是一个很好的工具。

为什么很多时候我们没有意识到正则对开发本身就是利器呢？因为现代的IDE，以及调试工具都集成了搜索功能。Contorl+p，可以在目录模糊匹配到对应的文件。Control+Shift+f，全局搜索，Control+f，当前文件中搜索。而最可能用到正则的地方，git命令的使用，也有好的带UI的软件替代。有工具已经帮我们实现了这些功能。

为什么我要写总结呢？因为IDE全局搜索很慢，即便摩尔定律使得计算机性能大幅提高。其二，IDE搜索，好处在于直观，坏在不灵活，不易与其他文本处理配合。
