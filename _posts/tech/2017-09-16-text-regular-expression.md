---
layout: post
title:  文本之正则表达式
category: 技术
tags: [text]
keywords:  text regular expression
description:
---

###  文本之正则表达式

#### Saturday, 16  2017 September

![ChengBi](/../../assets/img/tech/2017/ChengBi_3.jpg)

## 本质

### DFA与NFA

正则表达式有两种引擎，DFA和NFA。两者区别是DFA不支持捕获型括号(capturing parentheses)，不支持回溯(backreferences)。两者的具有相同的本质，他们都是自动状态机，都会从一个匹配的状态转移至下一个或几个状态。

DFA从一个状态转移至下一个确定的状态，而NFA则从一个状态转移至下一个不确定的状态。或者既然状态不确定，那么在程序中如何执行呢？NFA猜出所有的状态，并执行。如何猜呢？暴力遍历所有的可能的状态。从这个角度看，NFA是多个DFA的组合，故两者等价。但匹配的过程的差异，导致部分情况下NFA性能不如DFA，这个是显然的，NFA遍历的状态多于DFA。还有不显然的差异，由于NFA会记录遍历匹配的过程，故可以在匹配的历史中回溯，以及捕获其匹配的字符串。而在生产环境中，两者都是很有用的功能，故多数编程语言使用NFA。也有结合两者使用的情况，DFA可以获得好的性能，NFA可以有更多的功能。

### NFA的匹配本质有2种：

1. 匹配字符导致状态转移，如普通的字符；
2. 不用匹配字符就可以导致状态转移，即ε匹配，如括号；

### 匹配字符有4种情况：

1. 单个字符c的匹配；
2. 连接：(PQ)，如果字符串s1满足P，字符串s2满足Q，则s1s2满足(PQ)；
3. 或：`(P|Q)`，如果字符串s满足P或者Q，则s满足`(P|Q)`；
4. Kleene closure，`(P*)`。如果字符串s可以写成0个或多个字符串c的连接c1c2c3···，且每一个串都满足`(P*)`，则s满足`(P*)`。注意空字符串也满足。

其中克莱因闭包的优先级最高，连接次之，或最低。

## 第一原则

从实践的角度，写正则表达式，应该文本优先。即根据文本来构造正则表达式。我们知道匹配过程中有类似结构化编程中的三种结构，顺序(字符串)、选择(`| []`等结构)与循环(`+ *`等量词)。但如此会陷入细节中，导致考虑不全面，构造起来也不便捷。由于NFA是匹配优先，我们可以将字符串分组，用括号括起来即可。马上可以知道字符串的结构，然后分析三种情况，必须匹配，必须不匹配，可能匹配。用括号分割字符串，即可知道那些是必须匹配的，多数情况到这一步即可。

而正则表达式一般用4种情况：

1. 校验；（表单校验`/RegExp/.test(str)`,`str.indexOf(searchString)`）
2. 捕获；（url解析并获取参数`str.match(/RegExp/)`）
3. 替换；（模版引擎`str.replace(/RegExp/, (c) => { return c })`）
4. 切分；（以分隔符切分字符串`str.split(/RegExp/)`）

例子：匹配URL。`http://www.ora.com:80/goodparts?q#fragment`

1. `(http:)(//)(www.ora.com)(:80)(/goodparts)?(q)(#fragment)`

2. `/([A-Za-z]+)?(\/{0, 3})([0-9.\-A-Za-z]+)(\d+)?(\/\w+)?(\?\w+)?(#\w*)?/`

3. `/([A-Za-z]+)?(\/{0, 3})([0-9.\-A-Za-z]+)(\d+)?(\/\w+)?(\?[^?#]+)?(#(.*))?/`

4. `/^(?:([A-Za-z]+):)?(\/{0,3})([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$`

以上为构造URL的正则过程，分组时要留意匹配前后的关联性。尽量不使用`.*`，优先使用排他性字符组，使得匹配的结果更加精确，减少回溯，性能更好。过多的回溯，可能导致正则表达式的效率与最初级的字符串处理算法一样。


## 知识结构

### 缩写法

正则表达式是处理字符串的匕首，小而锋利。但也有正则表达式不能处理的情况，正则表达式的局限。比如，不存在能够描述所有合法正则表达式字符串的集合的正则表达式，其简化版：无法使用正则表达式检查括号是否匹配，检查字符串中A和B是否一样多。也就是正则表达式无法用自身描述自身。这其中困难之处在于，正则表达式用来处理字符串，而正则表达式本身也是用字符串描述的。字符串的组合千变万化，但总是在一个字符串集合中，正则表达式就是从这些集合中抽象处理来的模式，即某些字符串集合的缩写。

我们知道匹配到字符串导致状态转移有4中情况，其中连接和或是一种，而克莱因闭包是另一种。前者我们可以使用一个字符集来描述，如通配符`.`，字符组`[A-Z]`，补集`[^aeiou]`，以及简写`\w \d \s`。后者克莱因闭包则是各种量词，如`+ {1, } ? {0, 1} * {0, }`。

既然前面我们使用缩写来表示字符集，那么我们需要匹配这些表示缩写的字符时怎么办呢？在正则表达式中，处理这种情况的办法是使用转义，在字符之前加上斜杠即可。

### ε匹配

1. 括号：分组，非捕获分组

2. 断言：单个位置的断言，多个位置的断言

单个位置断言，常见的有`^ $`匹配字符串的开头与结束，本身不匹配任何字符，只匹配这个位置。以及单词边界`\b`。注意`^ $`的行为会受到`g`匹配模式的影响。见后文匹配模式。

多个位置的断言，即环视，这个翻译很贴切，环视的功能，就是在这里向前瞧瞧，或向后瞧瞧。这种匹配，不匹配字符串，而会匹配对这个位置出现的字符串集合的要求。分为几种情况，正向环视与逆向环视，肯定环视与否定环视。由于JavaScript只支持正向环视，这里重点介绍正向肯定环视`(?=...)`，否定的情况记法有所区别而已`(?!...)`。

环视具有普通匹配所不具备的地方：可以很简单的添加全局约束，且不影响原有的匹配。正则表达式多数时候是对字符串的局部处理，不易添加全局的约束。例如对HTML open tag标签的匹配，如果不使用环视，则`/<[^/][^>]*[^/]>/`，这里在所需要匹配的字符串`[^>]*`前后添加的约束条件`[^/]`，影响的匹配了，这个导致这个正则表达式无法匹配`<u>`，tag只有一个字符的情况。 而环视无需匹配，只作对位置的检查，故很容易解决掉这个问题：`/<(?!/)[^>]+(?>!/)/>/`。

另一个情况是，添加环视约束之后，环视使得匹配的结果更为精确。如在文本中匹配邮政编码，`/\d{6}/`，可能匹配了手机号码12345678910，添加环视`/(?<!\d)\d{6}(?!\d)/`。

有些语言没有提供字符组运算功能，如何匹配除去英语字符的中元音字符之外的所有字母呢？如果是`.NET`写作`[a-z-[aeiou]]`即可。没有这一功能的语言如何处理呢？`/(?![^aeiuo])[a-z]/`即可。

### 匹配模式

i：改变英语字母的行为，使得大小写不加区别的匹配；
g：改变了匹配过程，使得匹配不止步于第一次匹配成功，同时要注意，g使得lashIndex会记录上一次匹配的位置，多数情况是不必要的，需要重置为0；
m：改变了`^ $`的行为，使得每行开头均能匹配`^`，结尾匹配`$`;


## 技巧

### 日常使用的正则表达式

### 特殊技巧

## 易忽略的点

易犯错的点



## 参考资料：

正则指引 by 余晟

Algorithms by Robert Sedgewick and kevin Wayne

Mastering Regular Expressions Undrstand Your Data and Be More Productive by Jeffrey E.F. Friedl

JavaScript: The Good Parts by Douglas Crockford


Yvan say：很多时候，我们没有意识到正则表达式，其实对我们自身很有用处。正则的用处，不仅仅是用于面试，或者开发中做校验功能。正则对我们开发本身，就是一个很好的工具。

为什么很多时候我们没有意识到正则对开发本身就是利器呢？因为现代的IDE，以及调试工具都集成了搜索功能。Contorl+p，可以在目录模糊匹配到对应的文件。Control+Shift+f，全局搜索，Control+f，当前文件中搜索。而最可能用到正则的地方，git命令的使用，也有好的带UI的软件替代。有工具已经帮我们实现了这些功能。

为什么我要写总结呢？因为IDE全局搜索很慢，即便摩尔定律使得计算机性能大幅提高。其二，IDE搜索，好处在于直观，坏在不灵活，不易与其他文本处理配合。

我自己学习正则的过程中，读过一些文章，也读过一些书，同时在平日工作的过程中，所使用的正则表达式基本的复制过来的，想来汗颜。很多文章把正则表达式写成了类似参考手册的样子，罗列知识点，没法用线串起来。所幸正则表达式的书并不多，也就三两本而已，要么是余晟翻译的，要么是余晟写的。我读过余晟写的正则表达式的文章，是所有关于正则表达式文章中最好的，同时看得出作者对正则表达式很有一套，所以我重点读了他写的一本书《正则指引》，这本书我前前后后读了好多遍，但以前知识零碎的读，且没有归纳总结，跟白读了一样。这次在回家的火车上，十几个小时，从开始到结束，依照顺序读下来。发现作者对知识点的安排，是精心思考过的，前后的衔接，入手点的安排。读了之后我陷入的细节的海洋，虽然作者将知识点组织的很好，但我没有自己的组织，我无法得到一个简化之后的知识脉络。

我本来想要自己动手实现一个正则表达式的引擎的，回头去复习算法书，发现算法书上对正则表达式的描述很简洁，能直接表达正则表达式的本质。于是我依据这些简单的类似的数学描述，整理一下正则表达式的知识点，算是把书读薄了。

这里受刘未鹏的想法影响很大，对知识，我们要问三个问题：

1. 本质是什么？

2. 第一原则是什么？

3. 知识结构是怎样的？

文章也是按照这个组织材料。由于中间有中端，加上我读书又发现新的点，所以行文不流畅。先这么写出来，日后理解深入了，再修正。深入研究一下正则表达式，能体会到思维的乐趣。

一次实实在在的把乱七八糟的点捋顺的过程，把书读薄的感觉真好。当然，你要耐心，集中精力做一件事，一个星期内不换主题。正则表达式花了三周。

体会到自动状态机的强大，但为什么编程中不常用呢？因为规范化的状态机表达业务逻辑，不够灵活。但我们可以借鉴这个办法，在项目初期写好文档，画状态转化图，对写代码大有裨益。
