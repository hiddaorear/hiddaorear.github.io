---
layout: post
title:  Git
category: 技术
tags: [git]
keywords: git
description:
---

##### Tuesday, 03 November 2015

### Git

![起风了](/../../assets/img/tech/2015/Hayao_Miyazaki_1.jpg)

### check

#### `git branch -av`

- `-v`显示本地branch与对应的`origin branch`，以及最后一次的提交信息
- `-a`显示所有的branch，包含本地与远程

#### `git remote show origin`
显示origin的详细信息

#### cherry

````shell
git cherry -v other_branch_name
git cherry -v master
````
检查分支的改变，是否出现在其他分支。`+`表示没有出现在所给的分支中， `-`则反之。


### more clean

#### 创建一个无历史的branch，`git checkout --orphan new_branch_name`

#### 使用rebase而非merge，`git pull --rebase`
用来代替`fetch/merge`,会导致log中出现过多的信息，容易混淆。用以上命令行，减少无用的merge，保持历史记录的清晰。

### more convenience

#### 无需切换branch就从其他分支checkout文件，`git checkout branch_name -- file_path`


### pull强制覆盖本地文件

````shell

git fetch --all
git reset --hard origin/master

````

pull下来有diff，会有commit产生，但此时不需这些commit如何处理？
一般方案是reset到旧版本，然后再pull。在有些情况下，master分支出现问题，remore的代码比本地要旧，这样无论怎么pull和reset都会有commit产生，这是动用这个两个命令行的绝佳时机。

### 污染版本的补救

如果master有一个有问题的提交，并且大家都基于这个提交，修改了代码。从这个版本开始，问题必然会感染此后的所有版本。如何处理？

可以把此后提交所更新代码，提取出来，并reset至没有问题的commit，再把这些代码合并到此commit上。

### Patch

### git diff patch

````shell

git diff branch_name > path_name
git apply patch_name
git apply --check   # 貌似速度很慢，不知什么原因

````

### git format-patch patch

`git am [options] [(<mbox>|<Maildir>)...]`
`git am [options] (--continue | --skip | --abort)`

````shell

git format-patch -M master
git checkout -b for_patch
git am patch_name.patch    # gitformat-patch生成的文件

````

较为稳重一点的方案：

````shell

git apply --stat patch_name.patch
git apply --check patch_name.patch
git am --signoff patch_name.patch

````

### 注意，在使用`git am`之前，首先要`git am --abort`一次，放弃掉以前的am信息，这样才能进行一次全新的am。不然会遇到错误：
`.git/rebase-apply still exists but mbox given`

### 多个patch技巧
`git am *.patch`
git 会按文件名顺序am这些patch。

### 遇到am冲突
- 冲突无法解决，撤销所有am，`git am -abort`
- 忽略一个patch，`git am --skip`
- 需要手动处理的冲突。求修改patch文件，保持patch中内容一致。然后执行：`git am --resolved`


diff与format-patch比较

- 兼容性：diff较好；
- 除错功能：都不错；
- 版本信息：format-patch较好，补丁中含有开发者名字，可以用于邮件发送。

### git and diff and zip

git提取版本之间的差异文件，并打包

`git diff commit_id_0 commit_id_1 --name-only | xargs zip patch.zip`

解析：
git diff 使用`--name-only`参数，这只显示文件名，输出结果是diff文件的相对地址，而这正好是压缩命令的参数。shell命令`xargs`将前一个命令的输出，转化为另一个命令的参数。这样可以将diff文件一起打包，也就获得了增量上线包。

### archive

`git archive <branch> --format=<zip, tar> --output=<output path>`

#### demo

````shell
// gizp zip tar

git archive --output=files_name.tar HEAD $(git diff-tree -r --no-commit-id --name-only --diff-filter=ACMRT HEAD)

// zip

git archive --format=zip --output=files.tar HEAD $(git diff-tree -r --no-commit-id --name-only --diff-filter=ACMRT HEAD)

````
`--diff-filter=ACMRT`

- A = Added
- C = Copied
- M = Modified
- R = Renamed
- T = Changed

#### 代码压缩归档

````shell

git archive master --prefix='project/' | gizp > `git describe master`.tar.gz

// zip

git archive master --prefix='project/' | --format=zip > `git describe master`.zip

````

#### archive最后一次的改变

`git archive -o ../update.zip HEAD $(git diff --name-only HEAD^)`

#### archive两个提交之间的改变

`git archive -o ../latest.zip new_commit_id $(git diff --name-only old_commit_id new_commit_id)`














### 参考资料:
[图解Git](https://marklodato.github.io/visual-git-guide/index-zh-cn.html)
[Git 基础 - 查看提交历史](https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2)
[查看历史 －Git日志](http://gitbook.liuhui998.com/3_4.html)
[A successful Git branching model](http://nvie.com/posts/a-successful-git-branching-model/)
[一个成功的Git分支模型](http://www.juvenxu.com/2010/11/28/a-successful-git-branching-model/)
[Mercurial Workflows: Branch As Needed](http://stevelosh.com/blog/2010/02/mercurial-workflows-branch-as-needed/)
[Using git-flow to automate your git branching workflow](http://jeffkreeftmeijer.com/2010/why-arent-you-using-git-flow/)
[Git 分支的最佳实践](http://jiongks.name/blog/a-successful-git-branching-model/)
[Git 分支 - 分支的衍合](http://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E8%A1%8D%E5%90%88)
[请教大家是怎么使用 git 的分支的？](https://ruby-china.org/topics/4263)
[Git Interactive Rebase, Squash, Amend and Other Ways of Rewriting History](https://robots.thoughtbot.com/git-interactive-rebase-squash-amend-rewriting-history)
[Git 使用规范流程](http://www.ruanyifeng.com/blog/2015/08/git-use-process.html)
[Git 内部原理](http://git.oschina.net/progit/9-Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.html)
[高富帅们的Git技巧（译）](http://mux.alimama.com/posts/711)

[真正理解 git fetch, git pull 以及 FETCH_HEAD](https://ruby-china.org/topics/4768?page=1#replies)

### Patch
[Git的Patch功能](http://www.cnblogs.com/y041039/articles/2411600.html)
[向一个项目提交补丁](http://gitbook.liuhui998.com/5_6.html)
[读懂diff](http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html)
[git高级技巧](http://wiki.bitbegin.com/post/docs/4-git/2-git-geek-notes)

[git提取出两个版本之间的差异文件并打包](http://www.01happy.com/git-extract-different-files/)

### Archive
[git-archive doc](http://git-scm.com/docs/git-archive)
[10 个很有用的高级 Git 命令 ](http://www.oschina.net/translate/10-useful-advanced-git-commands)

hid say: 因git而变git，可谓不才。




