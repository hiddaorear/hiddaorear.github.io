# 耦合与编程范式

#### 2023/08/07 摘录pongba的TopLanguage

## 为什么GP更自然？

### 面向对象和GP

实现ADT，如stack。完成了一个stack类，用数组实现。函数foo要用到这个stack：

```cpp
void foo(stack)
```

面向对象：

按照面向对象的思路，要使得foo可以复用，所有的stack，比如，因为效率原因，要替换stack为一个链表实现，就需要抽象出一个IStack接口。此时，具体类尚未实现，或者刚刚写出来，就需要考虑抽象，可能过早抽象了。

```cpp
void foo(IStack);
```

GP：

GP的方式，把形参给虚化掉，当成无类型语言使用。

```cpp
void foo<Stack>(Stack s);
```

foo不依赖任何具体的interface，天生就依赖stack这个概念本身的抽象语义。


lijie的看法：GP的Stack，用concept来处理，和面向对象差别不大。不同的是面向对象是二进制复用，GP是源码级别复用。面向对象可以动态化绑定，GP只能静态绑定。

Jian Wang和longshanksmo对lijie的反驳：

- OOP和GP差别很大，OOP的二进制复用，会引入更多细节，interface难以稳定。如果IStack接口会依赖Stack中的元素类型，而元素类型和Stack没什么关系，foo也未必会关心元素类型，这正是GP的大显身手的地方。
- 并不是所有stack都实现了IStack，有些不是stack，但行为又是stack的东西，是实现IStack好还是不实现好？如果这个东西敲好有具备list的行为，是否应该还实现IList？

### GP和OOP的差异

> GP倾向于产生不同类型，OO倾向于提取出同一个类型

### OO的缺点

首先，OO对性能的降低再少，还是有降低，有时候一点降低也是不可接受的；
其次，OO的主要问题不是性能降低，而是OO容易造成系统的耦合。一个系统中，有无数的类，每个类不知道在干什么？而且互相有关联，就像一张蜘蛛网，造成严重的系统功能拓展和维护问题。

耦合是最大的问题。设计得好，加上抽象体系固有的稳定性（如GUI），OO固然能搭建出好的框架。然而，如云风所说，在实际中的一个典型系统，你敢保证两年以后，这个抽象体系还适用吗？到那个时候类已经叠床架屋了，怎么办？

模块之间的设计，重点就在于低耦合，越低越好。
模块内，避免过早抽象的同事，又能恰当避免依赖具体实现，折中办法是duck typing。

用OO设计的系统，拓展性和灵活性是需要事先准备的，GP则不同，这个点的影响很大。

OO需要事先准备好interface和基类，以及他们之间的关系，具体的类也需要准备好。将不同的类组装起来，需要粘合层。

《unix编程艺术》一书中，认为OOP带来的最大问题，是粘合层过厚。

GP是最后组装，最初设计的时候，只需要知道有相关的接受函数即可。有变化，只需要写一个粘合层即可。

### 粘合层

所谓粘合层，即没有实际业务领域对应的对象，只是负责将另外两种对象之间连接起来。

### 耦合

OO的接口耦合，可以看成是：一组函数签名+一个类型的耦合
GP比较宽泛，从concept来说，基于：函数名称和函数签名的耦合
委托、自由函数，去掉了名称和类型的耦合，只剩下函数签名

### concept

虽然定义了concept实质上也就定义了接口。GP的好处就是可以延迟定义concept。
用interface，要复用性，就必须一开始就定义出interface，因为若开始补定义interface，算法会耦合特定的类。

纯虚类、Concept和动态化语言的哈希表，用这三种东西的任何一种来实现多态，从设计角度看都是一回事，区别只在实现上。Concept运行速度最快，编译速度最慢，修改一处可能导致另一处重新编译的几率最大；动态语言运行速度最慢，编译速度最快，修改一处可能导致另一处重新编译的几率最小。纯虚类则介于二者之间。


## 耦合的三重境界

耦合的三重境界为：

- 实体耦合
- 接口耦合
- 签名耦合

最常见的是实体耦合：
```cpp
void f(Stack s) 
{
	//...
}
```

然后是接口耦合：
```cpp
void f(IStack s) 
{
	//...
}
```

最后是签名耦合：
```cpp
struct stack
{
	int (*pop)();
	void(*push)(int);
	//...
};

void f(struct stack s)
{
	//...
}
```

OO的语言，无一例外，鼓励用接口来实现复用。一个算法，要复用，就需要针对接口编程，而后者要求必须先提取接口，接口里面一组函数，每个都有名字，就引入了一组名字依赖，这个依赖远远强于刚才提到的签名依赖（delegate），其导致的后果是，如果将一个算法，应用到第三方库上的话，就需要做接口适配层，导致了不必要的粘合层。

C里面没有接口，只存在两种耦合，实体耦合和签名耦合。C里面要实现抽象，几乎唯一的办法是利用函数指针，有时候也会用到将函数指针捆绑成一个结构体。但请注意，这个跟接口的区别，接口函数有名字，如果一个类没有实现这个接口，但有其语义，就必须做一个adapter层。C里面的一组函数指针，其实是一组delegate，没有名字，任何签名相同的东西，都可以挂上面。C里面要实现抽象，往往是最小依赖，签名依赖已经小得不能再小了。我认为这也是为什么许多人觉得C做设计好的原因，因为他强迫你用最小依赖。

是否实现最低依赖，就必须求助于C的方式呢？

不然。GP提供了一个更好的方案。GP鼓励的泛化复用方式，不像OO那样针对接口，而是针对概念（Concept）。

比如`std::foreach`

```cpp
template< class InputIt, class UnaryFunction >
UnaryFunction for_each( InputIt first, InputIt last, UnaryFunction f );

```

这里的InputIt和UnaryFunction，其实都是delegate，for_each对他们的依赖只是签名依赖，而非接口依赖。

最关键的还是GP编程的泛化过程，鼓励的不是提升接口，而是提升概念，这些概念引入的依赖是签名依赖。

### 多态的绑定时机

- GP是编译时绑定
- OO是运行时绑定


## 聊聊API的设计

什么情况下用interface比GP更好呢？

有一种情况，对象是根据外部的相关信息创建的。即动多态场景。
如果你的代码需要使用该对象，那你可能需要一个interface。不同的外部信息，可能创建不同的对象，但所有这些对象，都需要你定义的interface。在代码中，通过interface，将业务逻辑分派下去。





## 文章列表

- [耦合的三重境界](https://groups.google.com/g/pongba/c/dnRCUVOMQ-Q)
- [《敏捷软件开发：原则、模式与实践》重读笔记（一）：寻找属于你的依赖](https://groups.google.com/g/pongba/c/1WzHqjFUaaY)
- [为什么GP更自然](https://groups.google.com/g/pongba/c/5VOiFHa6Lr0)
- [聊聊 API 设计](https://groups.google.com/g/pongba/c/Ss4wZ4035gY)
- [高阶特性与低阶语言的尴尬](https://groups.google.com/g/pongba/c/bVzIWvjTPFM)
